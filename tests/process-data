#!/usr/bin/env python

import subprocess
import argparse
import random
import errno
import os


def remove_file(filename):
    try:
        os.remove(filename)
    except OSError as e:
        # errno.ENOENT = no such file or directory
        if e.errno != errno.ENOENT:
            raise  # re-raise exception if a different error occured


def float_range(start, stop=None, step=1.0, error=0.00000001):
    if stop is None:
        stop = start
        start = 0.0
    if step <= 0:
        while start < (stop + error):
            yield start
            start += step
    else:
        while start < (stop - error):
            yield start
            start += step

parser = argparse.ArgumentParser()
parser.add_argument('-d', action='store',
                    dest='data',
                    required=True,
                    help='dataset name')
parser.add_argument('-k', action='store',
                    dest='clusters',
                    required=True,
                    help='number of clusters')
parser.add_argument('-n', action='store',
                    dest='iterations',
                    help='sample size')
args = parser.parse_args()
if args.iterations is None:
    args.iterations = 10

random.seed()

data_folder = "datasets/" + args.data + "/"
data = data_folder + args.data + ".dat"
yy_args = "./kmeans " + data + " -q -a yy -k " + args.clusters + " -s "

processed_data = data_folder + "processed.dat"
remove_file(processed_data)

for mult in [m for m in float_range(1.1, 2.1, 0.01)]:
    result = ([], [], [])
    for i in range(int(args.iterations)):
        seed = random.getrandbits(64)

        yy_out = subprocess.getoutput(yy_args + str(seed))
        yy_m_out = subprocess.getoutput(yy_args + str(seed) + " -m " + str(mult))

        yy_out = str.splitlines(yy_out)
        yy_m_out = str.splitlines(yy_m_out)

        # computa o ganho: com_mult% - sem_mult%
        result[0].append(float(yy_m_out[0]) - float(yy_out[0]))
        # conta o numero de erros
        result[1].append(sum([1 for a, b in zip(yy_out[1], yy_m_out[1]) if a != b]))
        # multiplicador utilizado
        result[2].append(mult)

    result = zip(result[0], result[1], result[2])
    with open(processed_data, 'a') as f:
        for col in result:
            f.write("{0},{1},{2}\n".format(*col))
