#!/usr/bin/env python
import subprocess as sp
import argparse
import random
import errno
import os
from sklearn.metrics.cluster import adjusted_rand_score


def remove_file(filename):
    try:
        os.remove(filename)
    except OSError as e:
        # errno.ENOENT = no such file or directory
        if e.errno != errno.ENOENT:
            raise  # re-raise exception if a different error occured


def float_range(start, stop=None, step=1.0, error=0.00000001):
    if stop is None:
        stop = start
        start = 0.0
    if step <= 0:
        while start < (stop + error):
            yield start
            start += step
    else:
        while start < (stop - error):
            yield start
            start += step

parser = argparse.ArgumentParser()
parser.add_argument('-d', action='store', dest='data',
                    required=True, help='dataset name')
parser.add_argument('-k', action='store', dest='clusters',
                    required=True, help='number of clusters')
parser.add_argument('-n', action='store', dest='iterations',
                    default='5',  help='number of iterations')
parser.add_argument('-o', action='store', dest='outfile',
                    default='processed',  help='outfile name')
args = parser.parse_args()

random.seed()

data_folder = "datasets/" + args.data + "/"
data = data_folder + args.data + ".dat"
yycmd = "taskset 4 ./kmeans " + data + " -q -a yy -k " + args.clusters + " -s "
acccmd = "taskset 8 ./kmeans " + data + " -q -a yy -k " + args.clusters + " -s "

outfile = data_folder + args.outfile + ".dat"
remove_file(outfile)

for mult in [m for m in float_range(1.5, 5.01, 0.25)]:
    for i in range(int(args.iterations)):
        seed = random.getrandbits(64)
        res2 = ([], [], [])
        res = ([], [], [])

        # taskset usado para diminuir a variabilidade no tempo
        yy = sp.getoutput(yycmd + str(seed))
        yy_acc = sp.getoutput(acccmd + str(seed) + " -m " + str(mult))

        yy = str.splitlines(yy)
        yy_acc = str.splitlines(yy_acc)

        # computa a diferenca em %
        res[0].append(1 - (float(yy_acc[0]) / float(yy[0])))
        # compara os agrupamentos
        res[1].append(adjusted_rand_score(list(yy[1]), list(yy_acc[1])))
        # multiplicador utilizado
        res[2].append(mult)

        res = zip(res[0], res[1], res[2])
        with open(outfile, 'a') as f:
            for col in res:
                f.write("{0},{1},{2}\n".format(*col))
